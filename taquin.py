from tkinter import *
from random import randrange
import itertools
import collections
import time


class Node:
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance
    - 'parent' is the preceding node generated by the solver, if any
    - 'action' is the action taken to produce puzzle, if any
    """
    def __init__(self, puzzle, parent=None, action=None):
        self.puzzle = puzzle
        self.parent = parent
        self.action = action
        if (self.parent != None):
            self.g = parent.g + 1    #profondeur de l'arbre
        else:
            self.g = 0


    @property
    def state(self):
        """
        Return a hashable representation of self
        """
        return str(self)

    @property 
    def path(self): # pour afficher le chemin
        """
        Reconstruct a path from to the root 'parent'
        """
        node, p = self, []
        while node:
            p.append(node)
            node = node.parent
        yield from reversed(p)

    @property
    def solved(self):#pour vérifier si on a trouvé la solution ou pas encore
        """ Wrapper to check if 'puzzle' is solved """
        return self.puzzle.solved

    @property
    def actions(self):
        """ Wrapper for 'actions' accessible at current state """
        return self.puzzle.actions

    @property
    def h(self): #estimation
        """"h"""
        #return self.puzzle.manhattan
        return self.puzzle.mal_placé
    @property
    def f(self): #heuristique
        """"f"""
        return self.h + self.g

    def __str__(self):#pour afficher le noeud (matrice)
        return str(self.puzzle)

class Solver:
    """
    An '8-puzzle' solver
    - 'start' is a Puzzle instance
    """
    def __init__(self, start): #start= puzzle instance
        self.start = start

    def solve(self):
        """
        Perform breadth first search and return a path
        to the solution, if it exists
        """
        print("-------résolution avec A*---------------")
        queue = collections.deque([Node(self.start)])
        seen = set() #ensemble contenant les noeuds developpés
        seen.add(queue[0].state)
        while queue:
            queue = collections.deque(sorted(list(queue), key=lambda node: node.f))#file triée selon l'heuristique
            node = queue.popleft()#on developpe la téte de la file
            if node.solved:  
                return node.path 

            for move, action in node.actions:
                child = Node(move(), node, action)

                if child.state not in seen:
                    queue.append(child)
                    seen.add(child.state)   
        print(node.actions)
    def solve1(self):#recherche en profondeur
        print("-------résolution avec recherche en profondeur---------------")
        queue = collections.deque([Node(self.start)])
        seen = set() #ensemble contenant les noeuds developpés
        seen.add(queue[0].state)
        while queue:
            node = queue.pop()
            if node.solved:
                return node.path

            for move, action in node.actions:
                child = Node(move(), node, action)             
                if child.state not in seen:
                    queue.append(child)
                    seen.add(child.state)
                   
    def solve2(self):#recherche en largeur
        print("-------résolution avec recherche en largeur---------------")
        queue = collections.deque([Node(self.start)])
        seen = set() #ensemble contenant les noeuds developpés
        seen.add(queue[0].state)
        while queue:
            node = queue.popleft()
            if node.solved:
                return node.path

            for move, action in node.actions:
                child = Node(move(), node, action)             
                if child.state not in seen:
                    queue.append(child)
                    seen.add(child.state)              
        
             

class Puzzle:
    """
    A class representing an '8-puzzle'.
    - 'board' should be a square list of lists with integer entries 0...width^2 - 1
       e.g. [[1,2,3],[4,0,6],[7,5,8]]
    """
    def __init__(self, board):
        self.width = len(board[0]) #=3
        self.board = board  #matrice contenant les nbres 

    @property
    def solved(self):
        """
        The puzzle is solved if the flattened board's numbers are in
        increasing order from left to right and the '0' tile is in the
        last position on the board
        """
        
        return str(self) == ''.join(map(str, range(1,9))) + '0'

    @property 
    def actions(self):
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'action'.
        """
        def create_move(at, to):
            return lambda: self._move(at, to)

        moves = []
        for i, j in itertools.product(range(3),#3
                                      range(3)):#3
            direcs = {'droite':(i, j-1),
                      'gauche':(i, j+1),
                      'bas':(i-1, j),
                      'haut':(i+1, j)}

            for action, (r, c) in direcs.items():
                if r >= 0 and c >= 0 and r < 3 and c < 3 and \
                   self.board[r][c] == 0:#il faut deplacer la case vide dans notre cas 0
                    move = create_move((i,j), (r,c)), action
                    moves.append(move)
        return moves #liste des paires(nouvelle matrice , operateur)

    @property
    def mal_placé (self):
        etat_final=[[1,2,3],[4,5,6],[7,8,0]]
        x=0
        for i in range(3):
            for j in range(3):
                if self.board[i][j]!=etat_final[i][j]:
                    x+=1
        return x            
                    
             
            
        

    def shuffle(self):
        """
        Return a new puzzle that has been shuffled with 1000 random moves
        """
        puzzle = self
        for _ in range(1000):
            puzzle = random.choice(puzzle.actions)[0]()
        return puzzle

    def copy(self):
        """
        Return a new puzzle with the same board as 'self'
        """
        board = []
        for row in self.board:
            board.append([x for x in row])
        return Puzzle(board)

    def _move(self, at, to): #permutation
        """
        Return a new puzzle where 'at' and 'to' tiles have been swapped.
        NOTE: all moves should be 'actions' that have been executed
        """
        copy = self.copy()
        i, j = at
        r, c = to
        copy.board[i][j], copy.board[r][c] = copy.board[r][c], copy.board[i][j]
        return copy

    def pprint(self):
        for row in self.board:
            print(row)
        print()

    def __str__(self):
        return ''.join(map(str, self))

    def __iter__(self):
       for row in self.board:
            yield from row

def clic(event):
    global i_empty, j_empty, bravo
    if bravo:
        return
    i=event.y//100
    j=event.x//100
    nro=board[i][j]
    rect, txt=items[nro]
    if j+1 ==j_empty and i==i_empty:
        cnv.move(rect, 100, 0)
        cnv.move(txt, 100, 0)
    elif j-1 ==j_empty and i==i_empty:
        cnv.move(rect, -100, 0)
        cnv.move(txt, -100, 0)
    elif i+1 ==i_empty and j==j_empty:
        cnv.move(rect, 0, 100)
        cnv.move(txt, 0, 100)
    elif i-1 ==i_empty and j==j_empty:
        cnv.move(rect, 0, -100)
        cnv.move(txt, 0, -100)
    else:
        return
    board[i][j],board[i_empty][j_empty]=(
        board[i_empty][j_empty],board[i][j])
    i_empty=i
    j_empty=j
    if board==win:
        lbl.configure(text="Bravo !")
        bravo=True

def voisins(n, i, j):
    return [(a,b) for (a, b) in
            [(i, j+1),(i, j-1), (i-1, j), (i+1,j)]
            if a in range(n) and b in range(n)]

def echange(board, empty):
    i, j=empty
    V=voisins(3, i, j)
    ii, jj=V[randrange(len(V))]
    board[ii][jj], board[i][j]=board[i][j],board[ii][jj]
    return ii, jj

def normal(board, empty):
    i_empty, j_empty = empty
    for i in range(i_empty, 3):
        (board[i][j_empty], board[i_empty][j_empty])= (
            board[i_empty][j_empty], board[i][j_empty])
        i_empty=i
    for j in range(j_empty, 3):
        board[i_empty][j], board[i_empty][j_empty]= (
            board[i_empty][j_empty],board[i_empty][j])
        j_empty=j

def melanger(N):
    board=[[3*lin+1+col for col in range(3)]
        for lin in range(3)]

    empty=(2,2)

    for i in range(N):
        empty=echange(board, empty)
    return board

def init(N=500):
    global i_empty, j_empty, items, board, bravo
    cnv.delete("all")
    items=[None]

    board=melanger(N)
    for i in range(3):
        for j in range(3):
            if board[i][j]==9:
                i_empty, j_empty=i, j

    empty=i_empty, j_empty
    normal(board, empty)
    i_empty, j_empty=2,2
    print(board)
    items=[None for i in range(10)]

    for i in range(3):
        for j in range(3):
            x, y=100*j, 100*i
            A, B, C=(x, y), (x+100, y+100), (x+50, y+50)
            rect = cnv.create_rectangle(A, B, fill="#bb57b0")
            nro=board[i][j]
            txt = cnv.create_text(C, text=board[i][j], fill="black",
                            font=FONT)
            items[nro]=(rect, txt)
    rect, txt=items[9]        
    cnv.delete(rect)
    cnv.delete(txt)
    lbl.configure(text="")
    bravo=False
#items=[None for i in range(10)]
#board=[[6, 7, 4 ],
#       [5, 8, 2],
#       [1, 3, 9]]

FONT=('Ubuntu', 27, 'bold')
master=Tk()
board = [[1,2,3],[4,5,0],[6,7,8]]
puzzl = Puzzle(board)
global s

def solv():
    s = Solver(puzzl)
    tic = time.perf_counter()
    p =s.solve()
    toc = time.perf_counter()
    steps = 0
    for node in p:
        print(node.action)
        node.puzzle.pprint()
        steps += 1

    print("Total number of steps: " + str(steps))
    print("Total amount of time in search: " + str(toc - tic) + " second(s)")
def solv11():
    s = Solver(puzzl)
    tic = time.perf_counter()
    p =s.solve1()
    toc = time.perf_counter()
    steps = 0
    for node in p:
        print(node.action)
        node.puzzle.pprint()
        steps += 1
    print("Total number of steps: " + str(steps))
    print("Total amount of time in search: " + str(toc - tic) + " second(s)")
def solv22():
    global s
    s =Solver(puzzl)
    tic = time.perf_counter()
    p =s.solve2()
  
    toc = time.perf_counter()
    steps = 0
    for node in p:
        print(node.action)
        node.puzzle.pprint()
        steps += 1

    print("Total number of steps: " + str(steps))
    print("Total amount of time in search: " + str(toc - tic) + " second(s)")



cnv=Canvas(master, width=300, height=300, bg='gray70')
cnv.pack(side='left')
master.title('Taquin')
btn=Button(text="Mélanger", command=init)
btn.pack()
btn=Button(text="Quitter", command=master.destroy)
btn.pack()
btn=Button(text="résolution avec A*",command=solv)
btn.pack()
btn=Button(text="résolution en profondeur",command=solv11)
btn.pack()
btn=Button(text="résolution en largeur",command=solv22)
btn.pack()


lbl=Label(text="      ", font=('Ubuntu', 25, 'bold'), 
          justify=CENTER, width=7)
lbl.pack(side="left")

"""i_empty, j_empty=2,2

for i in range(3):
    for j in range(3):
        x, y=100*j, 100*i
        A, B, C=(x, y), (x+100, y+100), (x+50, y+50)
        rect = cnv.create_rectangle(A, B, fill="#bb57b0")
        nro=board[i][j]
        txt = cnv.create_text(C, text=board[i][j], fill="black",
                            font=FONT)
        items[nro]=(rect, txt)
cnv.delete(rect)
cnv.delete(txt)
"""

cnv.bind("<Button-1>", clic)
init()

win=[[1, 2, 3],
     [4, 5, 6],
     [7, 8, 0]]

master.mainloop()